---
# Refactoring Rules & Code Smells

This file is the **canonical refactoring rulebook** for this project. It catalogs code smells and refactoring techniques based on Martin Fowlerâ€™s Refactoring Catalog and project-specific conventions. All contributors must follow these guidelines for code quality and maintainability.

For enforcement and integration details, see `.windsurfrules.md`.

---
## Code Smells
---

### Bloaters
*Code, data, or responsibilities have grown excessively large and are hard to work with.*

---

## Smell: Long Method

**ID:** `smell_long_method`
**Severity:** High
**Description:** A method, function, or procedure that has grown too long, making it difficult to understand, maintain, and reuse.
**Potential Problems:**
* Hard to understand, debug, and change.
* Promotes code duplication.
* Low cohesion; often mixes multiple responsibilities.
* Difficult to reuse parts of the logic.
* Increased likelihood of subtle errors.
**Refactorings (Solutions):**
* **Extract Method:** (See Rule: `ref_extract_method`)
* **Replace Temp with Query:** (See Rule: `ref_replace_temp_with_query`)
* **Decompose Conditional:** (See Rule: `ref_decompose_conditional`)
* **Introduce Parameter Object:** (See Rule: `ref_introduce_parameter_object`)
* **Replace Method with Method Object:** (See Rule: `ref_replace_method_with_method_object`)
* **Preserve Whole Object:** (See Rule: `ref_preserve_whole_object`)
**Tags:** `#bloaters`, `#comprehensibility`, `#maintenance`

---

## Smell: Large Class

**ID:** `smell_large_class`
**Severity:** High
**Description:** A class that is trying to do too much, often indicated by numerous instance variables, too many methods, or a very long source file. Violates the Single Responsibility Principle.
**Potential Problems:**
* Low cohesion and high coupling.
* Difficult to understand, test, and maintain.
* Often leads to `smell_duplicate_code`.
* Hard to reuse in other contexts.
**Refactorings (Solutions):**
* **Extract Class:** (See Rule: `ref_extract_class`)
* **Extract Subclass:** (See Rule: `ref_extract_subclass`)
* **Extract Interface:** (See Rule: `ref_extract_interface`)
* **Replace Data Value with Object:** (See Rule: `ref_replace_data_value_with_object`)
* **Replace Type Code with Subclasses:** (See Rule: `ref_replace_type_code_with_subclasses`)
**Tags:** `#bloaters`, `#organization`, `#single-responsibility`

---

## Smell: Primitive Obsession

**ID:** `smell_primitive_obsession`
**Severity:** Medium
**Description:** Over-reliance on primitive data types instead of creating small, meaningful objects for simple tasks (e.g., using strings for phone numbers, currency, or special codes).
**Potential Problems:**
* Loss of type safety and semantic meaning.
* Related data and behavior are scattered.
* Can lead to `smell_data_clumps` or long parameter lists.
* Implicit assumptions about primitive values (e.g., format, range).
**Refactorings (Solutions):**
* **Replace Data Value with Object:** (See Rule: `ref_replace_data_value_with_object`)
* **Replace Type Code with Class/Subclasses/State/Strategy:** (See Rule: `ref_replace_type_code_with_subclasses`, `ref_replace_type_code_with_state_strategy`)
* **Introduce Parameter Object:** (See Rule: `ref_introduce_parameter_object`)
* **Extract Class:** (See Rule: `ref_extract_class`) (If multiple primitives represent a coherent concept)
**Tags:** `#bloaters`, `#dispensables`, `#encapsulation`

---

## Smell: Long Parameter List

**ID:** `smell_long_parameter_list`
**Severity:** Medium
**Description:** A method has too many parameters, making it hard to understand and use.
**Potential Problems:**
* Reduced readability and usability of the method.
* High coupling; the method knows too much about its callers.
* Often indicates that some parameters could be grouped into an object.
* Can be a sign that the method is trying to do too much.
**Refactorings (Solutions):**
* **Introduce Parameter Object:** (See Rule: `ref_introduce_parameter_object`)
* **Preserve Whole Object:** (See Rule: `ref_preserve_whole_object`)
* **Replace Parameter with Method Call:** (If a parameter can be obtained by calling a method on another parameter or on the class itself) (See Rule: `ref_replace_parameter_with_method_call`)
* **Separate Query from Modifier:** (If parameters are used to query and also to modify, split the method) (See Rule: `ref_separate_query_from_modifier`)
**Tags:** `#bloaters`, `#method-signature`

---

## Smell: Data Clumps

**ID:** `smell_data_clumps`
**Severity:** Medium
**Description:** Groups of data items that frequently appear together in multiple places (e.g., parameters to methods, fields in several classes).
**Potential Problems:**
* Indicates missing classes or objects that should encapsulate this data.
* Makes method signatures longer and harder to understand if passed as individual parameters.
* Duplication of data groups across the codebase increases maintenance.
**Refactorings (Solutions):**
* **Introduce Parameter Object:** (See Rule: `ref_introduce_parameter_object`)
* **Extract Class:** (See Rule: `ref_extract_class`) (If the data clump has associated behavior or represents a clear concept)
* **Preserve Whole Object:** (See Rule: `ref_preserve_whole_object`)
**Tags:** `#bloaters`, `#organization`, `#duplication`

---
### Object-Orientation Abusers
*Solutions that don't fully or correctly leverage the possibilities of object-oriented design.*

---

## Smell: Switch Statements (or long if/else if chains)

**ID:** `smell_switch_statements`
**Severity:** Medium
**Description:** Complex switch statements or long sequences of if-then-else blocks that check for different types or conditions to decide on behavior. Often, a new condition requires changes in many such statements.
**Potential Problems:**
* Violates the Open/Closed Principle.
* Can lead to `smell_duplicate_code` if similar switches appear elsewhere.
* Difficult to maintain as new cases are added.
* Often indicates a place where polymorphism is needed.
**Refactorings (Solutions):**
* **Replace Conditional with Polymorphism:** (See Rule: `ref_replace_conditional_with_polymorphism`)
* **Replace Type Code with Subclasses/State/Strategy:** (See Rule: `ref_replace_type_code_with_subclasses`, `ref_replace_type_code_with_state_strategy`)
* **Introduce Null Object:** (See Rule: `ref_introduce_null_object`) (For handling null cases explicitly)
* **Decompose Conditional:** (See Rule: `ref_decompose_conditional`) (As a first step to simplify before applying polymorphism)
**Tags:** `#oo-abusers`, `#change-preventers`, `#polymorphism`

---

## Smell: Temporary Field

**ID:** `smell_temporary_field`
**Severity:** Low
**Description:** An instance variable that is set only in certain circumstances and is otherwise empty or null. Such fields are often confusing as their purpose isn't clear.
**Potential Problems:**
* Makes the object's state less predictable.
* Code becomes harder to understand because you need to track when the field is valid.
* Can indicate that the class is handling more than one responsibility.
**Refactorings (Solutions):**
* **Extract Class:** (See Rule: `ref_extract_class`) (Move the temporary field and related methods to a new class)
* **Introduce Null Object:** (See Rule: `ref_introduce_null_object`) (To represent the absence of the optional component)
* **Replace Method with Method Object:** (See Rule: `ref_replace_method_with_method_object`) (If the field is used within a complex algorithm in one method)
**Tags:** `#oo-abusers`, `#comprehensibility`

---

## Smell: Refused Bequest

**ID:** `smell_refused_bequest`
**Severity:** Medium
**Description:** A subclass uses only some of the methods and properties inherited from its parents, or uses them in a way that violates the parent's contract (Liskov Substitution Principle).
**Potential Problems:**
* Incorrect abstraction; the inheritance hierarchy may be wrong.
* Unnecessary complexity and confusion.
* May lead to overriding methods with empty implementations or exceptions.
**Refactorings (Solutions):**
* **Replace Inheritance with Delegation:** (See Rule: `ref_replace_inheritance_with_delegation`)
* **Extract Superclass/Push Down Method/Push Down Field:** Refine the hierarchy so subclasses inherit only relevant features. (See Rule: `ref_extract_superclass`, `ref_push_down_method`, `ref_push_down_field`)
**Tags:** `#oo-abusers`, `#inheritance`

---

## Smell: Alternative Classes with Different Interfaces

**ID:** `smell_alternative_classes_different_interfaces`
**Severity:** Medium
**Description:** Two or more classes that perform similar functions but have different method names or signatures for those functions.
**Potential Problems:**
* Client code needs to be aware of specific class types and their unique interfaces.
* Harder to use these classes polymorphically.
* Increased learning curve for users of these classes.
**Refactorings (Solutions):**
* **Rename Method:** (See Rule: `ref_rename_method`) (To make method names consistent)
* **Move Method:** (See Rule: `ref_move_method`) (If functionality is better suited in one or the other, or a common superclass)
* **Extract Superclass/Interface:** (See Rule: `ref_extract_superclass`, `ref_extract_interface`) (To define a common contract)
* **Parameterize Method:** (See Rule: `ref_parameterize_method`) (If differences can be handled by parameters)
**Tags:** `#oo-abusers`, `#consistency`, `#polymorphism`

---
### Change Preventers
*Code structures that make it hard to change one part of the system without affecting many other parts.*

---

## Smell: Divergent Change

**ID:** `smell_divergent_change`
**Severity:** High
**Description:** A single class is commonly changed in different ways for different reasons. For example, when adding a new product type, you have to change methods A, B, and C; when adding a new payment method, you have to change methods A, X, and Z in the same class.
**Potential Problems:**
* Violates the Single Responsibility Principle.
* Increases the risk of breaking unrelated functionality.
* Makes the class difficult to maintain and understand.
**Refactorings (Solutions):**
* **Extract Class:** (See Rule: `ref_extract_class`) (Separate the responsibilities that change for different reasons into different classes)
* **Move Method/Field:** (See Rule: `ref_move_method`, `ref_move_field`)
**Tags:** `#change-preventers`, `#single-responsibility`, `#maintenance`

---

## Smell: Shotgun Surgery

**ID:** `smell_shotgun_surgery`
**Severity:** High
**Description:** The opposite of Divergent Change. Making any single change requires you to make many small changes to many different classes.
**Potential Problems:**
* High coupling between classes.
* Changes are hard to track and easy to miss, leading to bugs.
* Increases the cost and risk of modifications.
**Refactorings (Solutions):**
* **Move Method/Field:** (See Rule: `ref_move_method`, `ref_move_field`) (To consolidate related logic into fewer classes)
* **Inline Class:** (See Rule: `ref_inline_class`) (If a class isn't doing much, merge it into another)
* **Extract Class:** (See Rule: `ref_extract_class`) (If a new class can centralize the distributed responsibility)
* **Hide Delegate:** (See Rule: `ref_hide_delegate`)
**Tags:** `#change-preventers`, `#coupling`, `#maintenance`

---

## Smell: Parallel Inheritance Hierarchies

**ID:** `smell_parallel_inheritance_hierarchies`
**Severity:** Medium
**Description:** Whenever you create a subclass for one class, you also need to create a subclass for another, and the subclass names often mirror each other. For example, `Vehicle`/`Car`/`Truck` and `VehicleDriver`/`CarDriver`/`TruckDriver`.
**Potential Problems:**
* Code duplication in creating and maintaining the hierarchies.
* Violates "Tell, Don't Ask" principle often.
* Making a change in one hierarchy often necessitates a similar change in the parallel one.
**Refactorings (Solutions):**
* **Move Method/Field:** (See Rule: `ref_move_method`, `ref_move_field`) (Make one hierarchy refer to instances of the other, rather than paralleling it.)
* **Replace Inheritance with Delegation:** (See Rule: `ref_replace_inheritance_with_delegation`)
**Tags:** `#change-preventers`, `#inheritance`, `#duplication`

---
### Dispensables
*Something in the code is unnecessary and should be removed to make the code cleaner, smaller, and more understandable.*

---

## Smell: Comments (as a deodorant for bad code)

**ID:** `smell_comments_as_deodorant`
**Severity:** Low (but can indicate deeper issues)
**Description:** Comments are sometimes used to explain confusing, poorly written, or overly complex code. The code itself should be clear and self-documenting. Comments should explain *why*, not *what*.
**Potential Problems:**
* Comments can become outdated and misleading.
* Often a sign that the code needs refactoring to be self-documenting.
* Can clutter the code and reduce signal-to-noise ratio.
**Refactorings (Solutions):**
* **Extract Method:** (See Rule: `ref_extract_method`) (If a comment explains a block of code)
* **Rename Method/Variable:** (See Rule: `ref_rename_method`, `ref_rename_variable`) (Use clearer names)
* **Introduce Assertion:** (See Rule: `ref_introduce_assertion`) (To clarify assumptions)
* **Decompose Conditional:** (See Rule: `ref_decompose_conditional`) (To simplify complex logic)
* **Replace Magic Number with Symbolic Constant:** (See Rule: `ref_replace_magic_number_with_symbolic_constant`)
**Tags:** `#dispensables`, `#comprehensibility`, `#documentation`

---

## Smell: Duplicate Code

**ID:** `smell_duplicate_code`
**Severity:** High
**Description:** The same or very similar code structure appears in more than one place.
**Potential Problems:**
* Increased maintenance overhead; changes need to be made in multiple places.
* Higher risk of bugs if not all duplicates are updated consistently.
* Makes the codebase unnecessarily larger and harder to understand.
**Refactorings (Solutions):**
* **Extract Method:** (See Rule: `ref_extract_method`)
* **Pull Up Method:** (See Rule: `ref_pull_up_method`) (If in subclasses of a common parent)
* **Form Template Method:** (See Rule: `ref_form_template_method`) (If subclasses perform similar steps with variations)
* **Extract Class:** (See Rule: `ref_extract_class`) (If duplicated code represents a distinct responsibility)
* **Replace Conditional with Polymorphism:** (See Rule: `ref_replace_conditional_with_polymorphism`) (If duplication is in conditional branches)
* **Substitute Algorithm:** (See Rule: `ref_substitute_algorithm`) (If duplication is due to different algorithms achieving the same result less clearly)
**Tags:** `#dispensables`, `#maintenance`, `#duplication`

---

## Smell: Lazy Class / Freeloader

**ID:** `smell_lazy_class`
**Severity:** Low
**Description:** A class that isn't doing enough to justify its existence (e.g., only contains a few methods or fields, or delegates most of its work).
**Potential Problems:**
* Unnecessary complexity in the class structure.
* Maintenance overhead for a class that provides little value.
**Refactorings (Solutions):**
* **Inline Class:** (See Rule: `ref_inline_class`) (Merge the class into another class that uses it most)
* **Collapse Hierarchy:** (See Rule: `ref_collapse_hierarchy`) (If it's a subclass with little added value)
**Tags:** `#dispensables`, `#organization`

---

## Smell: Data Class

**ID:** `smell_data_class`
**Severity:** Low-Medium
**Description:** A class that mainly contains fields and getter/setter methods (or public fields) but little or no other behavior. These are often manipulated by other classes.
**Potential Problems:**
* Breaks encapsulation; behavior related to the data is scattered elsewhere.
* Often leads to `smell_feature_envy` in other classes that operate on this data.
* Can be a sign of missing domain logic in the class itself.
**Refactorings (Solutions):**
* **Encapsulate Field/Collection:** (See Rule: `ref_encapsulate_field`, `ref_encapsulate_collection`)
* **Move Method:** (See Rule: `ref_move_method`) (Move behavior that operates on the data into the data class)
* **Extract Method:** (See Rule: `ref_extract_method`) (If methods in other classes are primarily working on the data of this class, extract parts and consider moving them)
* **Hide Method:** (If methods are not intended for public use) (See Rule: `ref_hide_method`)
**Tags:** `#dispensables`, `#oo-abusers`, `#encapsulation`

---

## Smell: Dead Code

**ID:** `smell_dead_code`
**Severity:** Medium
**Description:** Variables, parameters, fields, methods, or classes that are no longer used.
**Potential Problems:**
* Clutters the codebase, making it harder to understand and maintain.
* Can mislead developers into thinking it's important.
* Increases compile time and deployment size.
**Refactorings (Solutions):**
* **Remove Unused Code (Safely Delete):** The primary action. Requires good test coverage or careful analysis.
* **Collapse Hierarchy:** (See Rule: `ref_collapse_hierarchy`) (If a superclass becomes redundant after removing dead code from subclasses)
* **Remove Parameter:** (See Rule: `ref_remove_parameter`)
**Tags:** `#dispensables`, `#maintenance`

---

## Smell: Speculative Generality

**ID:** `smell_speculative_generality`
**Severity:** Low
**Description:** Code (e.g., classes, methods, parameters, hooks) created "just in case" for anticipated future needs that never materialize.
**Potential Problems:**
* Unnecessary complexity and abstraction.
* Harder to understand and maintain the current system.
* Can lead to `smell_dead_code` if the features are never used.
**Refactorings (Solutions):**
* **Collapse Hierarchy:** (See Rule: `ref_collapse_hierarchy`) (If abstract classes/interfaces are unused)
* **Inline Class/Method:** (See Rule: `ref_inline_class`, `ref_inline_method`) (If a simple abstraction isn't pulling its weight)
* **Remove Parameter:** (See Rule: `ref_remove_parameter`)
* **Rename Method/Class:** (See Rule: `ref_rename_method`) (To reflect actual, not speculative, use)
**Tags:** `#dispensables`, `#YAGNI` (You Aren't Gonna Need It)

---
### Couplers
*Forms of undesirable coupling between different parts of the codebase.*

---

## Smell: Feature Envy

**ID:** `smell_feature_envy`
**Severity:** Medium
**Description:** A method seems more interested in a class other than the one it actually is in. It accesses the data of another object (or calls its methods) much more than its own data/methods.
**Potential Problems:**
* Indicates poor encapsulation and misplaced responsibility.
* Increases coupling between classes.
* Makes the "envious" method's class harder to understand in isolation.
**Refactorings (Solutions):**
* **Move Method:** (See Rule: `ref_move_method`) (Move the method to the class it is "envious" of)
* **Extract Method:** (See Rule: `ref_extract_method`) (If only part of the method is envious, extract that part and then consider moving it)
* **Move Field:** (See Rule: `ref_move_field`) (Sometimes the data should move too)
**Tags:** `#couplers`, `#oo-abusers`, `#encapsulation`

---

## Smell: Inappropriate Intimacy

**ID:** `smell_inappropriate_intimacy`
**Severity:** Medium
**Description:** Two classes are too tightly coupled, spending too much time delving into each other's private parts (internal fields or methods).
**Potential Problems:**
* Changes in one class often force changes in the other.
* Reduced encapsulation.
* Harder to reuse classes independently.
**Refactorings (Solutions):**
* **Move Method/Field:** (See Rule: `ref_move_method`, `ref_move_field`) (To reduce the need for one class to access internals of another)
* **Extract Class:** (See Rule: `ref_extract_class`) (If a shared area of responsibility can be extracted)
* **Change Bidirectional Association to Unidirectional:** (See Rule: `ref_change_bidirectional_association_to_unidirectional`)
* **Replace Inheritance with Delegation:** (See Rule: `ref_replace_inheritance_with_delegation`)
* **Hide Delegate:** (See Rule: `ref_hide_delegate`)
* **Introduce Local Extension:** (See Rule: `ref_introduce_local_extension`) (If intimacy is with a library class)
**Tags:** `#couplers`, `#encapsulation`

---

## Smell: Message Chains

**ID:** `smell_message_chains`
**Severity:** Low-Medium
**Description:** A client requests an object from another object, which requests an object from yet another, and so on (e.g., `a.getB().getC().doSomething()`). This chain implies tight coupling to the structure of the navigation.
**Potential Problems:**
* High coupling; the client depends on the internal structure of multiple objects.
* Changes to the intermediate relationships in the chain break client code.
* Violates the Law of Demeter ("Talk only to your immediate friends").
**Refactorings (Solutions):**
* **Hide Delegate:** (See Rule: `ref_hide_delegate`) (The intermediate object should provide a method to do the work)
* **Extract Method:** (See Rule: `ref_extract_method`) (On an intermediate object to perform the final action, then use Hide Delegate)
* **Move Method:** (See Rule: `ref_move_method`)
**Tags:** `#couplers`, `#law-of-demeter`

---

## Smell: Middle Man

**ID:** `smell_middle_man`
**Severity:** Low
**Description:** A class that performs too many of its actions by simply delegating to other objects. If most of a class's interface consists of delegation, it might be redundant.
**Potential Problems:**
* Adds an unnecessary layer of indirection.
* Can increase overall complexity if the middle man isn't adding significant value.
**Refactorings (Solutions):**
* **Remove Middle Man:** (See Rule: `ref_remove_middle_man`) (Client calls the end delegate directly)
* **Inline Method:** (See Rule: `ref_inline_method`) (For simple delegations, then assess if class is still needed)
* **Replace Delegation with Inheritance:** (Rarely, if the middle man is a true subtype of the delegate) (See Rule: `ref_replace_delegation_with_inheritance`)
**Tags:** `#couplers`, `#dispensables`

---
## Smell: Incomplete Library Class

**ID:** `smell_incomplete_library_class`
**Severity:** Medium
**Description:** A library class (often third-party) lacks some methods you need, forcing you to add utility methods or workarounds in your own code.
**Potential Problems:**
* Workarounds can be clunky or spread out.
* Risk of duplicating these utility methods if multiple clients need them.
* Pollutes client code with logic that ideally belongs with the library's concept.
**Refactorings (Solutions):**
* **Introduce Foreign Method:** (Create a method in your client class that takes an instance of the library class as an argument). (See Rule: `ref_introduce_foreign_method`)
* **Introduce Local Extension:** (Create a new class that wraps or extends the library class to add the needed functionality). (See Rule: `ref_introduce_local_extension`)
**Tags:** `#couplers`, `#change-preventers`, `#external-dependencies`

---
---
## Refactorings
---

### Composing Methods
*Techniques for breaking down long methods into smaller, more understandable, and reusable pieces.*

---

## Refactoring: Extract Method

**ID:** `ref_extract_method`
**Purpose:** To turn a code fragment that can be grouped together into its own method. The method's name should clearly explain the purpose of the method.
**When to Use:**
* To reduce the length of a `smell_long_method`.
* To eliminate `smell_duplicate_code` by calling the new method from multiple places.
* To improve clarity when a `smell_comments_as_deodorant` is explaining a complex piece of logic.
* When a part of a method exhibits `smell_feature_envy` (as a first step before moving).
* To simplify complex conditional logic within `smell_decompose_conditional`.
**Benefits:**
* Improves code readability and understandability.
* Reduces code duplication.
* Encourages higher cohesion within methods.
* Allows for easier reuse of the extracted logic.
* Isolates changes.
**Related Smells:**
* `smell_long_method`
* `smell_duplicate_code`
* `smell_comments_as_deodorant`
* `smell_feature_envy`
* `smell_switch_statements`
* `smell_message_chains`
* `smell_data_class` (when extracting behavior for its data)
**Tags:** `#composing-methods`, `#core`

---

## Refactoring: Inline Method

**ID:** `ref_inline_method`
**Purpose:** To put the body of a method into the body of its callers and remove the method. It's the reverse of Extract Method.
**When to Use:**
* When a method's body is just as clear as its name.
* To remove an unnecessary indirection, often if the method is trivial.
* When refactoring has led to too many small, trivial methods that obscure the main flow.
* As an intermediate step in other refactorings (e.g., before `ref_replace_method_with_method_object` or `ref_move_method` if the method is too small to move meaningfully).
**Benefits:**
* Reduces indirection.
* Can make code easier to follow if methods were too fragmented.
* Can remove a `smell_middle_man` if its methods are inlined.
**Related Smells:**
* `smell_middle_man` (sometimes, for very simple delegations)
* `smell_lazy_class` (if its methods are inlined elsewhere making the class redundant)
* `smell_speculative_generality` (if the inlined method was an unnecessary abstraction)
**Tags:** `#composing-methods`

---

## Refactoring: Replace Temp with Query

**ID:** `ref_replace_temp_with_query`
**Purpose:** To replace a temporary variable that is assigned the result of an expression with a method that returns the result of that expression.
**When to Use:**
* Inside a `smell_long_method` to break it down and make it easier to understand.
* When a temporary variable is used to store the result of a calculation that can be clearly named and extracted.
* To simplify expressions before `ref_extract_method`.
* When the temporary variable is used multiple times.
**Benefits:**
* Improves readability by giving a meaningful name to the expression.
* Can help in identifying opportunities for `ref_extract_method`.
* Reduces the scope of local variables, making methods easier to reason about.
* Facilitates later extraction of the query method to another class.
**Related Smells:**
* `smell_long_method`
* `smell_comments_as_deodorant` (if the temp variable's purpose needed a comment)
**Tags:** `#composing-methods`

---

## Refactoring: Replace Method with Method Object

**ID:** `ref_replace_method_with_method_object`
**Purpose:** Turn a complex method into its own class where local variables become instance fields of the new class. This allows the method's logic to be decomposed into smaller methods within this new class.
**When to Use:**
* When a `smell_long_method` is very complex and has many local variables, making `ref_extract_method` difficult or resulting in many parameters being passed around.
* When you need a distinct strategy for a particular operation that has complex internal state.
* To resolve issues with `smell_temporary_field` if those fields are only used by one complex method.
**Benefits:**
* Allows complex logic to be broken down into more manageable pieces (methods within the new class).
* Can simplify the original class by isolating a complex operation.
* Facilitates more complex algorithms that might require their own state.
* Local variables become fields, making `ref_extract_method` easier within the new method object.
**Related Smells:**
* `smell_long_method`
* `smell_switch_statements` (sometimes a method object can represent a case, similar to State/Strategy)
* `smell_temporary_field` (if the temp fields are specific to one complex method)
**Tags:** `#composing-methods`, `#design-patterns` (related to Command or Strategy)

---

## Refactoring: Introduce Explaining Variable

**ID:** `ref_introduce_explaining_variable`
**Purpose:** Put the result of a complex expression or parts of it into a well-named temporary variable.
**When to Use:**
* When a complex expression is hard to understand.
* Within a `smell_long_method` to clarify parts of it.
* To break down complex conditional logic before further refactoring.
**Benefits:**
* Improves readability of complex expressions.
* Makes the code self-documenting.
* Can be a stepping stone to `ref_extract_method`.
**Related Smells:**
* `smell_long_method`
* `smell_comments_as_deodorant` (if comments explain an expression)
**Tags:** `#composing-methods`, `#comprehensibility`

---

## Refactoring: Split Temporary Variable

**ID:** `ref_split_temporary_variable`
**Purpose:** If a temporary variable is assigned to more than once and these assignments have different meanings (i.e., the variable serves multiple unrelated purposes), replace it with multiple distinct temporary variables, one for each meaning/purpose.
**When to Use:**
* When a temp variable is reused for different, unrelated purposes, making its role unclear.
* This often occurs in `smell_long_method`.
* When a variable's value has a different meaning at different points in its lifecycle.
**Benefits:**
* Each variable has a single, clear responsibility.
* Improves code clarity and reduces confusion.
* Makes it easier to perform other refactorings like `ref_extract_method`.
**Related Smells:**
* `smell_long_method`
**Tags:** `#composing-methods`

---

## Refactoring: Remove Assignments to Parameters

**ID:** `ref_remove_assignments_to_parameters`
**Purpose:** If a parameter is assigned a new value within the method body, use a local temporary variable instead for the new value.
**When to Use:**
* When a parameter is treated like a local variable by being reassigned within the method. This can be confusing, especially with pass-by-value-of-reference semantics in some languages.
* To clarify the role of the parameter as an input.
**Benefits:**
* Clarity: the initial value of the parameter remains clear throughout the method.
* Avoids unexpected side effects if the language passes objects by reference and the reassignment has unintended consequences for the caller.
* Makes code easier to understand and refactor.
**Related Smells:**
* `smell_long_method` (often seen in such methods)
**Tags:** `#composing-methods`, `#clarity`

---

## Refactoring: Substitute Algorithm

**ID:** `ref_substitute_algorithm`
**Purpose:** Replace a complex or unclear algorithm with one that is simpler, more efficient, or clearer, while producing the same observable results.
**When to Use:**
* When an existing algorithm is hard to understand or maintain.
* When a more standard or efficient algorithm is available.
* To simplify logic before other refactorings.
* Often, a `smell_long_method` contains a convoluted algorithm.
**Benefits:**
* Improves clarity and understandability.
* Can improve performance.
* Makes the code easier to maintain and debug.
**Related Smells:**
* `smell_long_method`
* `smell_comments_as_deodorant` (if comments are trying to explain a complex algorithm)
* `smell_duplicate_code` (if a clearer algorithm would avoid subtle duplications)
**Tags:** `#composing-methods`, `#clarity`, `#performance`

---
### Moving Features Between Objects
*Relocating responsibilities (methods or fields) to more appropriate classes.*

---

## Refactoring: Move Method

**ID:** `ref_move_method`
**Purpose:** To move a method to a class where it is more appropriate, usually the class that contains most of the data the method uses or is most closely related to its functionality.
**When to Use:**
* To resolve `smell_feature_envy` where a method is more interested in another class.
* When a method in one class calls another class more than it calls methods in its own class.
* To improve cohesion and reduce coupling.
* When addressing `smell_large_class` by distributing responsibilities.
* To centralize behavior with the data it operates on, helping `smell_data_class`.
**Benefits:**
* Increases cohesion within classes.
* Reduces coupling between classes.
* Makes class responsibilities clearer.
* Improves encapsulation.
**Related Smells:**
* `smell_feature_envy`
* `smell_large_class`
* `smell_shotgun_surgery` (by centralizing related logic)
* `smell_data_class` (by moving behavior to the data)
* `smell_inappropriate_intimacy`
* `smell_message_chains` (sometimes a method moved to an intermediate object can shorten a chain)
* `smell_parallel_inheritance_hierarchies`
**Tags:** `#moving-features`, `#cohesion`, `#coupling`

---

## Refactoring: Move Field

**ID:** `ref_move_field`
**Purpose:** To move a field to a class that uses it more or where it makes more sense semantically.
**When to Use:**
* When a field is used by another class more than its own (a form of `smell_feature_envy` for data).
* To support `ref_move_method` if the moved method relies on this field.
* When addressing `smell_large_class` by distributing data responsibilities.
* To improve cohesion of classes.
* When a field on one class is primarily modified or used by methods on another class.
**Benefits:**
* Improves class cohesion.
* Reduces coupling if the field was causing other classes to interact with the original class inappropriately.
* Clarifies class responsibilities.
* Strengthens encapsulation if the field is better protected in its new home.
**Related Smells:**
* `smell_feature_envy`
* `smell_large_class`
* `smell_data_clumps` (if moving fields helps form a new cohesive object)
* `smell_shotgun_surgery` (by centralizing related data)
* `smell_inappropriate_intimacy`
* `smell_parallel_inheritance_hierarchies`
**Tags:** `#moving-features`, `#cohesion`, `#coupling`

---

## Refactoring: Extract Class

**ID:** `ref_extract_class`
**Purpose:** To create a new class and move relevant fields and methods from an overly complex or large class into it. This is used when a class is doing work that should be done by two (or more) distinct classes.
**When to Use:**
* To address a `smell_large_class` that has multiple distinct responsibilities.
* When `smell_data_clumps` are identified that could logically form a new object with associated behavior.
* When a subset of methods and data in a class would be better managed and reused separately.
* To resolve `smell_divergent_change` by separating unrelated responsibilities.
* When `smell_temporary_field` suggests an optional component that could be its own class.
* To break down a class that is subject to `smell_shotgun_surgery` if part of it can be self-contained.
**Benefits:**
* Improves cohesion within classes (Single Responsibility Principle).
* Reduces coupling between unrelated responsibilities.
* Makes classes smaller, easier to understand, test, and maintain.
* Can lead to better reusable components.
**Related Smells:**
* `smell_large_class`
* `smell_data_clumps`
* `smell_divergent_change`
* `smell_primitive_obsession` (if extracting a concept class around related primitives)
* `smell_temporary_field`
* `smell_shotgun_surgery` (by creating a central place for a distributed responsibility)
* `smell_inappropriate_intimacy` (by creating a boundary)
* `smell_comments_as_deodorant` (if comments try to delineate responsibilities within one class)
**Tags:** `#moving-features`, `#organizing-data`, `#single-responsibility`

---

## Refactoring: Inline Class

**ID:** `ref_inline_class`
**Purpose:** To merge a class into another class by moving all its features into that other class and deleting the original. It's the reverse of Extract Class.
**When to Use:**
* When a class (`smell_lazy_class`) isn't doing very much and its responsibilities can be easily absorbed by another class that uses it heavily.
* To remove an unnecessary indirection when a class simply delegates most of its work.
* When refactoring has led to a class that no longer has a clear, distinct purpose or represents a meaningful abstraction.
* To undo a previous `ref_extract_class` that proved unhelpful.
**Benefits:**
* Reduces the number of classes, simplifying the overall structure if the inlined class was trivial.
* Can remove unnecessary delegation and improve performance slightly by reducing indirection.
* Colocates closely related behavior and data.
**Related Smells:**
* `smell_lazy_class`
* `smell_middle_man` (if the middle man is a simple class that can be absorbed)
* `smell_shotgun_surgery` (sometimes consolidating small, overly fragmented classes can help)
* `smell_speculative_generality` (if the class was an unneeded abstraction)
**Tags:** `#moving-features`, `#organization`, `#simplification`

---

## Refactoring: Hide Delegate

**ID:** `ref_hide_delegate`
**Purpose:** If a client is calling a method on a delegate object obtained from a server object (e.g., `manager = john.getDepartment().getManager()`), create a new method on the server object that delegates the call, hiding the delegate from the client (e.g., `manager = john.getDepartmentManager()`).
**When to Use:**
* To reduce coupling by preventing clients from navigating an object's internal structure (`smell_message_chains`).
* To adhere to the Law of Demeter.
* When the structure of delegation might change, and you want to shield clients from that change.
* When a server class exposes an object that clients then use extensively, increasing coupling to that exposed object's interface.
**Benefits:**
* Reduces coupling between the client and the delegate (the object further down the chain).
* Simplifies client code as it interacts with fewer objects directly.
* Allows the server class to manage its delegation without affecting clients, improving encapsulation.
* Makes the server's interface more stable.
**Related Smells:**
* `smell_message_chains`
* `smell_feature_envy` (if the client is envious of the delegate and using the server just as a stepping stone)
* `smell_inappropriate_intimacy` (if clients are too aware of the server's internal collaborators)
**Tags:** `#moving-features`, `#encapsulation`, `#law-of-demeter`, `#decoupling`

---

## Refactoring: Remove Middle Man

**ID:** `ref_remove_middle_man`
**Purpose:** If a class is doing too much simple delegation (acting as a `smell_middle_man`), make the client call the delegate directly. This is the reverse of Hide Delegate.
**When to Use:**
* When a class primarily consists of methods that simply delegate to another object and adds no significant value or abstraction.
* When the indirection provided by the middle man is unnecessary and adds complexity without benefit.
* If the delegate's interface is stable and clients using it directly isn't a problem.
**Benefits:**
* Reduces indirection and the number of classes if the middle man becomes obsolete.
* Can make interactions more direct and clear if the delegation was trivial.
* Slightly improves performance by removing a layer of method calls.
**Related Smells:**
* `smell_middle_man`
* `smell_lazy_class` (if the class's only job was delegation)
**Tags:** `#moving-features`, `#simplification`, `#decoupling`

---

## Refactoring: Introduce Foreign Method

**ID:** `ref_introduce_foreign_method`
**Purpose:** To add a method to a class that you cannot modify (e.g., a library class) by creating the method in a client class (or a new utility class), taking an instance of the "foreign" class as the first argument.
**When to Use:**
* When you need additional behavior from a class in an external library that you can't change.
* To address `smell_incomplete_library_class` for one or a few missing operations.
* When the new behavior is closely tied to the foreign class but doesn't fit well within the existing client class's primary responsibility.
**Benefits:**
* Keeps utility code related to the foreign class in one place (either the client or a dedicated helper).
* Makes it clear that the method is an extension of the foreign class's functionality without altering the foreign class.
* Avoids scattering utility logic across multiple clients.
**Related Smells:**
* `smell_incomplete_library_class`
**Tags:** `#moving-features`, `#dealing-with-external-code`, `#utility-methods`

---

## Refactoring: Introduce Local Extension

**ID:** `ref_introduce_local_extension`
**Purpose:** To add functionality to a class from an external library (that you can't modify) by creating a new class that wraps the original class (using composition/delegation - Adapter pattern) or inherits from it (subclassing - if the library class is designed for it).
**When to Use:**
* When you need to add multiple methods or significant new behavior to a library class (`smell_incomplete_library_class`).
* When `ref_introduce_foreign_method` would lead to too many standalone utility methods, making the client class bloated or the utility class disorganized.
* To provide a modified or extended interface to the library class, better suited for your system.
* Subclassing is viable if the library class is designed for extension; wrapping (Adapter) is often safer and more flexible.
**Benefits:**
* Provides a clear place for custom extensions to the library class, grouping related functionalities.
* Can create a more cohesive set of extended functionalities.
* Can adapt the library class's interface to one more suitable for your system (Adapter).
* Decouples the rest of your system from the specifics of the original library interface.
**Related Smells:**
* `smell_incomplete_library_class`
* `smell_inappropriate_intimacy` (if your code is too coupled to the library's internals)
**Tags:** `#moving-features`, `#dealing-with-external-code`, `#adapter-pattern`, `#decorator-pattern` (if adding responsibilities dynamically)

---
### Organizing Data
*Improving how data is structured, stored, and accessed.*

---

## Refactoring: Replace Data Value with Object

**ID:** `ref_replace_data_value_with_object`
**Purpose:** To turn a data item that has its own associated data and behavior from a simple data type (primitive) into an object.
**When to Use:**
* To address `smell_primitive_obsession` where a primitive type is being used to represent a more complex concept (e.g., phone number, money, range, date range, special string codes).
* When a data value needs associated behavior (e.g., validation, formatting, comparison, arithmetic).
* When several primitive fields are always used together and represent a single concept (`smell_data_clumps`).
**Benefits:**
* Encapsulates data and related behavior together in one place (the new object).
* Improves type safety and code clarity by introducing semantic types.
* Can reduce `smell_data_clumps` by grouping related primitives.
* Makes code more object-oriented and easier to understand and maintain.
**Related Smells:**
* `smell_primitive_obsession`
* `smell_data_clumps`
* `smell_large_class` (by creating more focused small objects for its attributes)
* `smell_switch_statements` (if logic depends on primitive values that could become methods on the new object)
**Tags:** `#organizing-data`, `#encapsulation`, `#value-object`

---

## Refactoring: Introduce Parameter Object

**ID:** `ref_introduce_parameter_object`
**Purpose:** To group parameters that naturally belong together into a new class/structure.
**When to Use:**
* When you observe `smell_data_clumps` being passed to multiple methods (`smell_long_parameter_list`).
* To shorten long parameter lists, especially if several parameters represent a coherent concept.
* When some parameters are consistently passed together, indicating a missing abstraction.
**Benefits:**
* Reduces the number of parameters in method signatures, making them cleaner and easier to understand.
* Makes the relationship between the data elements explicit by grouping them in an object.
* Can centralize behavior related to this group of data within the new parameter object.
* Improves code readability.
**Related Smells:**
* `smell_data_clumps`
* `smell_long_parameter_list`
* `smell_primitive_obsession` (if the parameters are primitives forming a concept)
**Tags:** `#organizing-data`, `#simplifying-method-calls`, `#data-transfer-object`

---

## Refactoring: Preserve Whole Object

**ID:** `ref_preserve_whole_object`
**Purpose:** Instead of getting several values from an object and passing them as separate parameters to a method, pass the whole object itself.
**When to Use:**
* When you are calling a method and passing multiple values that are all obtainable from a single source object.
* To shorten a `smell_long_parameter_list`.
* If the called method might need more data from the source object in the future (reduces future signature changes).
* When the called method logically operates on the concept represented by the whole object.
**Benefits:**
* Reduces parameter list length, simplifying method calls.
* Makes the dependency on the source object explicit.
* More robust to changes if the called method needs different data from the source object later.
* Can reduce coupling if the called method no longer needs to know about the internal structure of the parameters it was previously receiving.
**Related Smells:**
* `smell_long_parameter_list`
* `smell_data_clumps` (if the clumps come from one object)
* `smell_long_method` (often has methods that extract many values to pass elsewhere)
**Tags:** `#organizing-data`, `#simplifying-method-calls`, `#decoupling`

---

## Refactoring: Self Encapsulate Field

**ID:** `ref_self_encapsulate_field`
**Purpose:** To replace direct access to a private field within its own class with accessor methods (getter/setter), even for internal access.
**When to Use:**
* Before making a field's storage or retrieval more complex (e.g., lazy initialization, calculated value, validation on set).
* When you want to add logic around field access (e.g., validation, logging, notifying observers) consistently.
* To provide a consistent way of accessing the field, which can be useful if subclass behavior needs to change how the field is derived or stored.
* When direct field access is spread throughout a class, making it hard to manage changes to that field.
**Benefits:**
* Increases flexibility for changing how the field is stored or calculated without affecting multiple points within the class.
* Provides a single point for adding behavior on get/set.
* Can make it easier for subclasses to override data retrieval/storage behavior.
* Improves maintainability.
**Related Smells:**
* Can preemptively avoid issues related to direct field access when complexity grows in a `smell_large_class`.
**Tags:** `#organizing-data`, `#encapsulation`, `#maintainability`

---

## Refactoring: Replace Type Code with Subclasses

**ID:** `ref_replace_type_code_with_subclasses`
**Purpose:** If you have a type code (e.g., an integer or string) that affects behavior and doesn't change after object creation, replace it with distinct subclasses for each type code value, moving type-specific behavior to these subclasses.
**When to Use:**
* When behavior changes based on a type code (often seen in `smell_switch_statements` or conditionals).
* When the type code is fixed at instantiation (immutable type).
* To enable polymorphism and avoid explicit type checks.
* When adding new types requires modifying existing conditional logic.
**Benefits:**
* Replaces conditional logic with polymorphic dispatch, making code cleaner and easier to extend.
* Adheres to the Open/Closed Principle (new types can be added by adding new subclasses without modifying existing code).
* Encapsulates type-specific behavior within the subclasses.
* Improves code organization and readability.
**Related Smells:**
* `smell_switch_statements`
* `smell_primitive_obsession` (if the type code is a primitive)
* `smell_large_class` (if type-specific logic bloats the main class)
* `smell_divergent_change` (if changes for different types affect the same class)
**Tags:** `#organizing-data`, `#dealing-with-generalization`, `#polymorphism`, `#open-closed-principle`

---

## Refactoring: Replace Type Code with State/Strategy

**ID:** `ref_replace_type_code_with_state_strategy`
**Purpose:** If you have a type code that affects behavior and *can change during the object's lifecycle*, or if subclassing is impractical (e.g., too many type combinations), replace the type code with a State or Strategy object.
**When to Use:**
* When behavior changes based on a type code, and this type can change dynamically during an object's lifetime.
* When `ref_replace_type_code_with_subclasses` is not feasible (e.g., too many type codes, or the object needs to change its "type" behavior).
* To avoid large `smell_switch_statements` based on the type code that selects behavior.
* When different algorithms (strategies) need to be applied interchangeably.
**Benefits:**
* Allows an object's behavior to change at runtime by changing its state/strategy object.
* Encapsulates state-specific or strategy-specific behavior in separate classes.
* Reduces conditional complexity in the main class (context class).
* Follows the Open/Closed Principle (new states/strategies can be added without modifying the context).
**Related Smells:**
* `smell_switch_statements`
* `smell_primitive_obsession` (for the type code)
* `smell_long_method` (if bloated with state-dependent logic)
* `smell_large_class` (if managing many states/strategies internally)
**Tags:** `#organizing-data`, `#dealing-with-generalization`, `#design-patterns` (State, Strategy), `#behavioral-patterns`

---

## Refactoring: Replace Subclass with Fields

**ID:** `ref_replace_subclass_with_fields`
**Purpose:** If subclasses only differ by returning constant data from methods (i.e., they don't have distinct behavior, just distinct data), and there's no other type-specific behavior, remove the subclasses and use fields in the superclass to hold this constant data.
**When to Use:**
* When subclasses are trivial and only vary by the values they provide via overridden methods that return constants (e.g., `getColor()` returns "Red" in `RedCar` and "Blue" in `BlueCar`).
* When the hierarchy is shallow and doesn't add much value in terms of behavioral polymorphism.
* To simplify an overly complex or unnecessary class hierarchy.
* When the differences between subclasses can be represented by data.
**Benefits:**
* Reduces the number of classes in the system, simplifying the design.
* Simplifies the design if the inheritance was not providing true behavioral polymorphism.
* Makes it easier to add new "types" by just adding new data instances rather than new classes.
**Related Smells:**
* Overly complex or unnecessary inheritance hierarchies.
* `smell_speculative_generality` (if the hierarchy was created for variations that are just data).
* `smell_lazy_class` (if subclasses are very trivial).
**Tags:** `#organizing-data`, `#dealing-with-generalization`, `#simplification`

---

## Refactoring: Encapsulate Field

**ID:** `ref_encapsulate_field`
**Purpose:** Make a public field private and provide public accessor methods (getter and, if necessary, setter).
**When to Use:**
* When a field is public, allowing uncontrolled direct access and modification from outside the class.
* To regain control over how a field's data is accessed and modified.
* As a first step towards more complex field management (e.g., validation, lazy loading).
**Benefits:**
* Protects the internal state of an object, enforcing invariants.
* Allows validation or other logic to be added during field access/modification without changing client code.
* Decouples the internal representation of the data from its public interface.
* Improves maintainability and reduces the impact of changes to the field's implementation.
**Related Smells:**
* `smell_data_class` (often have public fields or trivial getters/setters that could be made more robust by true encapsulation)
* `smell_inappropriate_intimacy` (if external classes directly manipulate public fields)
**Tags:** `#organizing-data`, `#encapsulation`, `#information-hiding`

---

## Refactoring: Encapsulate Collection

**ID:** `ref_encapsulate_collection`
**Purpose:** If a class exposes a mutable collection (e.g., list, set, map) through a getter that returns the raw collection, change it to prevent external modification. This can be done by returning a read-only view/copy of the collection, or by providing dedicated add/remove/access methods on the owning class.
**When to Use:**
* When clients can directly get and modify a collection held by an object, breaking its encapsulation and potentially violating its invariants.
* To control how elements are added or removed from a collection, perhaps with validation or side effects.
* When the owning class needs to maintain control over the state of its collection.
**Benefits:**
* Prevents uncontrolled modification of an object's internal collection by external clients.
* The class maintains ownership and control over its collection, ensuring its integrity.
* Allows for validation, logging, or other side effects when elements are added/removed.
* Decouples clients from the specific type of collection used internally.
**Related Smells:**
* `smell_data_class` (if it exposes collections directly)
* `smell_inappropriate_intimacy`
**Tags:** `#organizing-data`, `#encapsulation`, `#information-hiding`

---

## Refactoring: Replace Magic Number with Symbolic Constant

**ID:** `ref_replace_magic_number_with_symbolic_constant`
**Purpose:** Replace a literal number (or string literal) that has a specific meaning with a constant that has a descriptive name.
**When to Use:**
* When a raw number (e.g., `if (status == 2)`) or string literal appears in the code without explanation for its meaning.
* To improve readability and maintainability by giving semantic meaning to otherwise arbitrary values.
* When the same literal value is used in multiple places for the same purpose.
**Benefits:**
* Improves code readability by making the meaning of the value clear.
* Makes it easier to change the value if needed (only change the constant definition, not every occurrence).
* Avoids errors from inconsistent use or typos of the same magic number.
* Centralizes the definition of special values.
**Related Smells:**
* `smell_comments_as_deodorant` (if a comment explains the magic number)
* `smell_primitive_obsession` (sometimes related when primitives are used as flags or specific values)
**Tags:** `#organizing-data`, `#comprehensibility`, `#maintainability`

---

## Refactoring: Change Value to Reference

**ID:** `ref_change_value_to_reference`
**Purpose:** If you have many equal instances of a value object that are conceptually the same entity, change them so that they all refer to a single reference object.
**When to Use:**
* When you have multiple value objects representing the same conceptual entity (e.g., multiple "USD" currency objects) and you want to ensure they are all the *same* object.
* To save memory if value objects are large and numerous.
* To allow sharing of mutable state if the object becomes a reference type (use with caution).
* Often used for flyweight patterns or canonical representations.
**Benefits:**
* Ensures that conceptually identical objects are physically identical.
* Can save memory.
* Can simplify equality checks (reference equality might suffice).
**Related Smells:**
* Can address issues if `smell_primitive_obsession` led to many value-like objects that should be canonical.
**Tags:** `#organizing-data`, `#identity`, `#flyweight-pattern`

---

## Refactoring: Change Reference to Value

**ID:** `ref_change_reference_to_value`
**Purpose:** If a reference object is small, immutable, and its identity is not important, change it to a value object that is judged by its content.
**When to Use:**
* When a small, immutable object doesn't need a distinct identity (e.g., a `Point` or `DateRange` object).
* To simplify copying and distribution of the object (value objects are easily copied).
* When you want to ensure that equality is based on state, not identity.
**Benefits:**
* Simpler to reason about as there are no side effects from shared references.
* Easier to make immutable.
* Equality is based on content, which is often more intuitive for data-like objects.
**Related Smells:**
* If complex reference semantics are used for simple, data-like objects.
**Tags:** `#organizing-data`, `#immutability`, `#value-object`

---
### Simplifying Conditional Expressions
*Making conditional logic easier to read and manage.*

---

## Refactoring: Decompose Conditional

**ID:** `ref_decompose_conditional`
**Purpose:** To extract complex conditional logic (the condition itself) and the code in the `if`, `then`, and `else` blocks into separate, well-named methods.
**When to Use:**
* When you have a complicated conditional (if-then-else) statement that is hard to read, often found in a `smell_long_method`.
* To clarify the intent of the condition and each branch of a conditional.
* As a first step before `ref_replace_conditional_with_polymorphism`.
**Benefits:**
* Improves readability and understanding of complex logic by giving meaningful names to parts of it.
* Makes the conditional structure simpler by highlighting the conditions and actions.
* Can highlight `smell_duplicate_code` if the extracted methods are similar.
* Easier to debug.
**Related Smells:**
* `smell_long_method`
* `smell_switch_statements`
* `smell_comments_as_deodorant` (if comments explain parts of the conditional)
**Tags:** `#simplifying-conditional-expressions`, `#composing-methods`, `#clarity`

---

## Refactoring: Consolidate Conditional Expression

**ID:** `ref_consolidate_conditional_expression`
**Purpose:** If you have multiple conditional checks that all result in the same action or return value, combine them into a single conditional expression using logical operators (AND, OR).
**When to Use:**
* When a sequence of `if` statements or `else if` branches perform the same action or return the same result based on different but related conditions.
* To make the overall condition that leads to a particular outcome clearer and more concise.
* When you have multiple conditions that can be logically grouped.
**Benefits:**
* Reduces duplication of the resulting action/return statement.
* Makes the condition that leads to the action more explicit and easier to understand.
* Often a precursor to `ref_extract_method` for the combined condition or the resulting action.
**Related Smells:**
* `smell_duplicate_code` (in the action part of conditionals)
**Tags:** `#simplifying-conditional-expressions`, `#duplication`, `#clarity`

---

## Refactoring: Consolidate Duplicate Conditional Fragments

**ID:** `ref_consolidate_duplicate_conditional_fragments`
**Purpose:** If the same code fragment is executed in all branches of a conditional expression (e.g., at the beginning or end of each `if`/`else if`/`else` block), move that common code outside the conditional.
**When to Use:**
* When identical code appears at the beginning or end of all `if`/`else if`/`else` blocks.
* To avoid redundancy and make the unique parts of each branch clearer.
**Benefits:**
* Removes `smell_duplicate_code`.
* Simplifies the conditional logic by focusing on what's different in each branch.
* Improves maintainability as changes to the common fragment only need to be made in one place.
**Related Smells:**
* `smell_duplicate_code`
**Tags:** `#simplifying-conditional-expressions`, `#duplication`

---

## Refactoring: Remove Control Flag

**ID:** `ref_remove_control_flag`
**Purpose:** Replace a control flag variable (a boolean variable that is set within a loop or conditional to control its flow) with `break`, `continue`, or `return` statements, or by restructuring the loop/conditional.
**When to Use:**
* When a loop has a boolean flag that is set within the loop to determine if it should exit or continue, making the logic harder to follow.
* To make loop termination or conditional paths clearer and more direct.
* When the control flag obscures the real condition for exiting or continuing.
**Benefits:**
* Simplifies loop and conditional logic, making exit conditions more explicit.
* Reduces the number of variables to track.
* Often makes the code more readable and less error-prone.
**Related Smells:**
* `smell_long_method` (control flags often appear in complex loops within long methods)
* Code that is hard to reason about due to indirect control flow.
**Tags:** `#simplifying-conditional-expressions`, `#control-flow`, `#clarity`

---

## Refactoring: Replace Nested Conditional with Guard Clauses

**ID:** `ref_replace_nested_conditional_with_guard_clauses`
**Purpose:** If a method has conditional behavior that checks for "abnormal" or edge cases before proceeding with the main logic, replace nested conditionals with a sequence of "guard clauses" (early exits like `return`, `throw`, or `continue`).
**When to Use:**
* When you have deeply nested `if-else` structures where outer conditions are prerequisites for inner ones.
* When some conditions are checks for exceptional cases that should terminate the method early.
* To make the "happy path" or main flow of the method clearer by getting rid of edge cases at the top.
**Benefits:**
* Flattens conditional logic, making it much easier to read and reducing nesting depth.
* Clearly separates exceptional/edge case handling from the normal execution path.
* Reduces cognitive load when trying to understand the method's main purpose.
**Related Smells:**
* `smell_long_method` (often contain deeply nested conditionals)
* `smell_switch_statements` (if deeply nested or leading to arrows of code)
* `smell_comments_as_deodorant` (trying to explain the nesting)
**Tags:** `#simplifying-conditional-expressions`, `#control-flow`, `#readability`

---

## Refactoring: Replace Conditional with Polymorphism

**ID:** `ref_replace_conditional_with_polymorphism`
**Purpose:** If you have a conditional (like a switch or if/else chain) that chooses different behavior based on the type of an object or some state, move each leg of the conditional into an overriding method in a subclass or a separate strategy/state class. The original method then calls the polymorphic method.
**When to Use:**
* To eliminate `smell_switch_statements` or complex if/else logic based on type or state.
* When you want to add new variations of behavior without modifying existing code (Open/Closed Principle).
* Typically used in conjunction with `ref_replace_type_code_with_subclasses` or `ref_replace_type_code_with_state_strategy`.
* When different objects respond to the same message in different ways.
**Benefits:**
* Removes complex conditional logic from client code, making it cleaner.
* Makes it easy to add new behaviors by creating new subclasses/implementations without touching existing, tested code.
* Distributes responsibility for different behaviors to the appropriate classes, improving cohesion.
* Reduces `smell_duplicate_code` if similar conditionals exist elsewhere.
**Related Smells:**
* `smell_switch_statements`
* `smell_long_method` (if the method is dominated by such a conditional)
* `smell_feature_envy` (if the conditional logic is more interested in the types it's switching on)
* `smell_duplicate_code` (if the same switch logic appears in multiple places)
* `smell_primitive_obsession` (if switching on primitive type codes)
**Tags:** `#simplifying-conditional-expressions`, `#dealing-with-generalization`, `#polymorphism`, `#design-patterns`, `#open-closed-principle`

---

## Refactoring: Introduce Null Object

**ID:** `ref_introduce_null_object`
**Purpose:** Instead of using `null` checks or returning `null` from methods that provide optional collaborators, create a special "null" object that implements the expected interface but provides default "do nothing" or "return default" behavior.
**When to Use:**
* When you frequently check for `null` before calling methods on an object that might be absent.
* To simplify client code by removing numerous conditional null checks.
* When an object can have an optional collaborator, and you want to avoid null pointer exceptions.
* When `null` represents a specific, non-exceptional case that can have default behavior.
**Benefits:**
* Reduces the number of `null` checks in client code, making it cleaner and less error-prone.
* Prevents `NullPointerExceptions` or equivalent errors by providing a non-null default.
* The Null Object can provide specific default behavior that is more meaningful than just doing nothing (e.g., a "NullCustomer" might return "Guest" for name).
* Makes client code more robust.
**Related Smells:**
* `smell_switch_statements` (if one case is handling null)
* `smell_temporary_field` (if the field can be null and requires checks, a Null Object can be its default)
* Code littered with `if (object != null)` checks.
**Tags:** `#simplifying-conditional-expressions`, `#dealing-with-generalization`, `#design-patterns` (Null Object pattern), `#robustness`

---

## Refactoring: Introduce Assertion

**ID:** `ref_introduce_assertion`
**Purpose:** To document and programmatically check assumptions about the state of your program at a particular point. Assertions state conditions that are expected to be true.
**When to Use:**
* When a certain condition or state is assumed to be true for a piece of code to work correctly (preconditions, postconditions, invariants).
* To catch errors early during development and testing by failing fast if an assumption is violated.
* To clarify code by making assumptions explicit rather than implicit.
**Benefits:**
* Makes assumptions explicit, improving code understanding and documentation.
* Helps detect bugs closer to their origin, making debugging easier.
* Can serve as a form of executable documentation for preconditions, postconditions, or invariants.
**Note:** Assertions are typically for development/testing and might be disabled in production environments for performance reasons (depending on the language/platform). They should not be used for handling business logic errors that need to be gracefully caught and managed (use exceptions or other error handling for that).
**Related Smells:**
* `smell_comments_as_deodorant` (if a comment explains an assumption that could be an assertion)
* Code that fails in mysterious ways due to violated implicit assumptions.
**Tags:** `#simplifying-conditional-expressions`, `#documentation`, `#debugging`, `#defensive-programming`

---
### Simplifying Method Calls
*Making method calls clearer, simpler, and easier to use.*

---

## Refactoring: Rename Method

**ID:** `ref_rename_method`
**Purpose:** Change the name of a method to one that better reveals its purpose.
**When to Use:**
* When a method's current name is unclear, misleading, too generic, or doesn't accurately describe what it does.
* To improve code readability and self-documentation.
* When addressing `smell_alternative_classes_different_interfaces` to create consistency in naming.
**Benefits:**
* Improves code clarity and understandability significantly.
* Reduces the need for explanatory `smell_comments_as_deodorant`.
* Makes the system easier to learn and use.
**Related Smells:**
* `smell_comments_as_deodorant` (if comments explain a poorly named method)
* `smell_alternative_classes_different_interfaces`
* `smell_speculative_generality` (if a generic name was used for a specific purpose)
**Tags:** `#simplifying-method-calls`, `#comprehensibility`, `#documentation`

---
## Refactoring: Rename Variable (Implied, often part of other refactorings)

**ID:** `ref_rename_variable`
**Purpose:** Change the name of a variable (local, field, parameter) to one that better reveals its purpose.
**When to Use:**
* When a variable's current name is unclear, misleading, too generic (e.g., `i`, `j`, `temp`, `data`, `flag`), or doesn't accurately describe its content or role.
* To improve code readability and self-documentation.
**Benefits:**
* Improves code clarity and understandability significantly.
* Reduces the need for explanatory `smell_comments_as_deodorant`.
* Makes debugging easier.
**Related Smells:**
* `smell_comments_as_deodorant` (if comments explain poorly named variables)
* `smell_long_method` (often have poorly named or reused variables)
* `smell_primitive_obsession` (giving a primitive a good name can be a first step)
**Tags:** `#comprehensibility`, `#documentation`

---

## Refactoring: Add Parameter

**ID:** `ref_add_parameter`
**Purpose:** Add a new parameter to a method to pass in more information that the method needs to perform its task or to vary its behavior.
**When to Use:**
* When a method needs more information from its caller to perform its job correctly or more flexibly.
* When a method's behavior needs to be varied based on new input that isn't available within the method or its class.
* Sometimes an intermediate step when `ref_extract_method` requires data from the original scope.
**Benefits:**
* Allows methods to be more flexible and reusable in different contexts.
* Can make a method more self-contained if it previously relied on global state or less direct means of getting information.
**Tags:** `#simplifying-method-calls`, `#flexibility`

---

## Refactoring: Remove Parameter

**ID:** `ref_remove_parameter`
**Purpose:** Remove a parameter that is no longer used by the method or whose value can be obtained by other means within the method.
**When to Use:**
* When a parameter is not used within the method body (`smell_dead_code` related).
* If the parameter's value can be obtained within the method through other means (e.g., from a field of the class, by calling another method on an existing parameter or field).
* If a parameter was part of `smell_speculative_generality` and never used.
**Benefits:**
* Simplifies the method signature, making it easier to call and understand.
* Reduces coupling if the parameter was unnecessary and forced callers to provide information they didn't need to.
* Cleans up dead code.
**Related Smells:**
* `smell_dead_code` (for parameters)
* `smell_speculative_generality`
* `smell_long_parameter_list` (removing unneeded ones is a key step)
**Tags:** `#simplifying-method-calls`, `#decoupling`, `#YAGNI`

---

## Refactoring: Separate Query from Modifier (Command-Query Separation)

**ID:** `ref_separate_query_from_modifier`
**Purpose:** If a method both returns a value (queries state) and changes the state of an object (modifier/command), split it into two separate methods: one that only queries (returns a value without side effects) and one that only modifies (changes state, usually returns void or a status).
**When to Use:**
* When a method has side effects (modifies state) but also returns a value that isn't just a status of the side effect (e.g., `int popAndReturnElement()`).
* To adhere to the Command-Query Separation principle, which states that methods should either be commands (perform an action) or queries (return data to the caller), but not both.
* To avoid unexpected side effects when calling a method that appears to be a simple query.
**Benefits:**
* Makes method behavior clearer, more predictable, and easier to reason about.
* Reduces the chance of bugs caused by unexpected side effects when a developer thinks they are only querying data.
* Query methods can be called multiple times safely without altering state.
* Improves testability.
**Related Smells:**
* Methods with unclear responsibilities or hidden side effects.
* `smell_long_parameter_list` (if parameters are for both query and modification aspects).
**Tags:** `#simplifying-method-calls`, `#command-query-separation`, `#predictability`, `#testability`

---

## Refactoring: Parameterize Method

**ID:** `ref_parameterize_method`
**Purpose:** If you have several methods that do very similar things but with different literal values embedded in them, consolidate them into a single method that takes a parameter for the varying value(s).
**When to Use:**
* To reduce `smell_duplicate_code` across methods that differ only by constants or easily parameterizable logic.
* When methods implement the same basic algorithm but with different inputs or configurations that can be passed as parameters.
* To create a more general and reusable method.
**Benefits:**
* Reduces code duplication, leading to easier maintenance.
* Makes the code more flexible as the behavior can be controlled by parameters.
* Can reveal a more general underlying abstraction.
**Related Smells:**
* `smell_duplicate_code`
* `smell_alternative_classes_different_interfaces` (if methods in different classes are similar and could be unified with parameters, possibly after moving them to a common class)
**Tags:** `#simplifying-method-calls`, `#duplication`, `#generalization`

---

## Refactoring: Replace Parameter with Explicit Methods

**ID:** `ref_replace_parameter_with_explicit_methods`
**Purpose:** If a method's behavior is chosen by the value of a parameter (e.g., a flag, an enum, or a type code that controls internal conditional logic), create separate, clearly named methods for each possible value or distinct behavior path. This is the reverse of Parameterize Method.
**When to Use:**
* When a method has a parameter that acts as a control flag, leading to complex conditional logic inside the method to handle different cases.
* To make the interface clearer and more intention-revealing â€“ clients call specific methods (e.g., `enableCaching()`, `disableCaching()`) rather than passing flags (`setCache(true)`, `setCache(false)`).
* When the different execution paths are conceptually distinct operations.
**Benefits:**
* Improves interface clarity; method names explicitly state the action.
* Avoids conditional logic based on the parameter inside the method, simplifying its implementation.
* Makes client code easier to read and understand.
* Reduces the chance of passing invalid flag values.
**Related Smells:**
* `smell_switch_statements` (if based on a parameter's value)
* `smell_long_method` (if the parameter-driven conditional logic is complex)
* `smell_primitive_obsession` (if the parameter is a primitive flag)
**Tags:** `#simplifying-method-calls`, `#clarity`, `#interface-design`

---

## Refactoring: Replace Parameter with Method Call

**ID:** `ref_replace_parameter_with_method_call`
**Purpose:** If a caller calculates a value and passes it as a parameter to a method, but the called method could also calculate this value itself (or get it from another object it knows, like one of its fields or another parameter), remove the parameter and let the method obtain the value internally.
**When to Use:**
* When a parameter can be easily and logically derived by the receiving method itself or from objects it already has access to.
* To simplify method calls by reducing the burden on the caller to compute and provide the parameter.
* When the parameter's value is redundant because it can be obtained from existing context within the called method.
**Benefits:**
* Simplifies method signatures, making them shorter and easier to call.
* Reduces the coupling on the specific parameter value, as the caller no longer needs to compute it.
* The called method becomes more self-sufficient and less dependent on the caller providing derived data.
* Can improve readability if the internal calculation is clear.
**Related Smells:**
* `smell_long_parameter_list`
* When callers are doing work that the callee could do.
**Tags:** `#simplifying-method-calls`, `#decoupling`, `#encapsulation`

---

## Refactoring: Hide Method

**ID:** `ref_hide_method`
**Purpose:** If a method is not intended to be used by other classes (it's an internal implementation detail), make it private (or protected if meant for subclasses only).
**When to Use:**
* When a public method is only used internally by its own class or is an auxiliary part of a larger operation not meant for external clients.
* To reduce the public interface of a class, thereby minimizing coupling and improving encapsulation.
* To prevent accidental misuse of internal helper methods by external clients.
**Benefits:**
* Strengthens encapsulation by exposing only what's necessary.
* Reduces the surface area of the class, making it easier to understand and maintain.
* Gives more freedom to change the hidden method's implementation or signature without affecting external clients.
* Prevents clients from depending on implementation details.
**Related Smells:**
* `smell_large_class` (can have too many public methods that should be private helpers)
* `smell_inappropriate_intimacy` (if other classes are using methods that should be private)
* `smell_data_class` (often have public setters that might be better hidden if data is set only internally)
**Tags:** `#simplifying-method-calls`, `#encapsulation`, `#information-hiding`, `#interface-design`

---
### Dealing with Generalization
*Managing inheritance hierarchies, interfaces, and polymorphism effectively.*

---

## Refactoring: Pull Up Method

**ID:** `ref_pull_up_method`
**Purpose:** If subclasses have methods that perform the same work or have common parts, move that method or its common parts to the superclass.
**When to Use:**
* To eliminate `smell_duplicate_code` found in methods of subclasses.
* When a behavior is common to all or most subclasses and logically belongs to the superclass concept.
* To define a common interface or provide a default implementation in the superclass.
**Benefits:**
* Reduces code duplication, improving maintainability.
* Centralizes common logic in the superclass, making it easier to modify.
* Makes the inheritance hierarchy clearer and expresses commonality.
* Can enable `ref_form_template_method` if the pulled-up method calls abstract methods defined in subclasses.
**Related Smells:**
* `smell_duplicate_code`
* `smell_parallel_inheritance_hierarchies` (if common methods can be pulled up in one hierarchy)
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#duplication`, `#abstraction`

---

## Refactoring: Pull Up Field

**ID:** `ref_pull_up_field`
**Purpose:** If subclasses have the same field (name and meaning), move it to the superclass.
**When to Use:**
* To eliminate duplicate field declarations in subclasses.
* When a piece of data is common to all subclasses and represents a shared attribute of the superclass concept.
**Benefits:**
* Reduces code duplication.
* Centralizes data definition, improving consistency and maintainability.
* Makes the shared nature of the field explicit in the superclass.
**Related Smells:**
* `smell_duplicate_code` (for field definitions)
* `smell_parallel_inheritance_hierarchies`
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#duplication`

---

## Refactoring: Pull Up Constructor Body

**ID:** `ref_pull_up_constructor_body`
**Purpose:** If constructors in subclasses have common code, move that common code into the superclass's constructor and ensure subclass constructors call it (e.g., via `super()` in Java/C#).
**When to Use:**
* When constructors in subclasses share common initialization logic for superclass fields or other setup (`smell_duplicate_code`).
* To ensure consistent initialization of common superclass parts across all subclasses.
**Benefits:**
* Reduces code duplication in constructors.
* Ensures consistent initialization of the superclass portion of objects.
* Simplifies subclass constructors.
**Related Smells:**
* `smell_duplicate_code`
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#duplication`

---

## Refactoring: Push Down Method

**ID:** `ref_push_down_method`
**Purpose:** If a method in a superclass is only relevant to some of its subclasses (or only one), move it to those specific subclasses where it is actually used.
**When to Use:**
* When a behavior in a superclass is not used by all subclasses, making the superclass less cohesive (`smell_refused_bequest` implicitly).
* To improve cohesion in the superclass by removing behavior not universally applicable to all its subtypes.
* When a method in the superclass only makes sense for certain specific subtypes.
**Benefits:**
* Makes the superclass more cohesive and focused on common responsibilities.
* Clarifies that the behavior is specific to certain subclasses.
* Reduces the interface of the superclass if the method was public.
* Avoids subclasses inheriting irrelevant methods.
**Related Smells:**
* `smell_refused_bequest`
* `smell_large_class` (for the superclass, by shedding specialized methods)
* `smell_speculative_generality` (if the method was put in the superclass "just in case")
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#cohesion`

---

## Refactoring: Push Down Field

**ID:** `ref_push_down_field`
**Purpose:** If a field in a superclass is only used by some subclasses (or only one), move it to those specific subclasses where it is actually needed.
**When to Use:**
* When a field in a superclass is not relevant to all subclasses.
* To improve cohesion in the superclass by removing data not universally applicable.
* When a field in the superclass only makes sense for certain specific subtypes.
**Benefits:**
* Makes the superclass more cohesive and focused on common data.
* Ensures subclasses only declare and carry fields they actually need.
* Reduces memory footprint for instances of subclasses that don't use the field.
**Related Smells:**
* `smell_refused_bequest` (for data)
* `smell_large_class` (for the superclass)
* `smell_speculative_generality`
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#cohesion`

---

## Refactoring: Extract Subclass

**ID:** `ref_extract_subclass`
**Purpose:** If a class has features (methods or data) that are used only in some instances, or whose behavior varies based on some type code or condition that is fixed for an instance, create a new subclass for that specific variation and move the relevant features/behavior there.
**When to Use:**
* When a class has behavior or data that applies only to a subset of its instances based on some intrinsic characteristic.
* To handle variations expressed through type codes or conditional logic that differentiate object types.
* As part of `ref_replace_type_code_with_subclasses`.
* When addressing `smell_large_class` by breaking out specific, coherent variations.
* When some instance variables are only used when a type code has a certain value.
**Benefits:**
* Clearly defines variations in behavior or data structure within a dedicated class.
* Can simplify the original class by removing specific-case logic or data.
* Enables polymorphism for the variations, replacing conditional logic.
* Improves code organization and makes new variations easier to add.
**Related Smells:**
* `smell_large_class`
* `smell_switch_statements` (based on an object's type)
* `smell_primitive_obsession` (for type codes that define subtypes)
* `smell_temporary_field` (if fields are only relevant for a certain "type" of the object)
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#polymorphism`, `#open-closed-principle`

---

## Refactoring: Extract Superclass

**ID:** `ref_extract_superclass`
**Purpose:** If two or more classes share common features (methods or fields), create a common abstract superclass for them and move the common features (data and behavior) to it.
**When to Use:**
* When there's `smell_duplicate_code` (methods or fields) across multiple classes that represent variations of a similar concept or abstraction.
* To establish a common interface or shared default implementation for a group of related classes.
* To improve abstraction by explicitly defining the shared aspects of related classes.
* When you want to be able to treat instances of these classes polymorphically through a common supertype.
**Benefits:**
* Reduces code duplication, improving maintainability.
* Expresses commonality and abstraction explicitly in the type system.
* Allows for polymorphic use of the subclasses through the superclass type.
* Provides a single place to modify shared behavior or data.
**Related Smells:**
* `smell_duplicate_code`
* `smell_alternative_classes_different_interfaces` (if a common superclass can unify them by defining shared methods)
* `smell_parallel_inheritance_hierarchies` (sometimes a better shared superclass can simplify one or both hierarchies)
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#duplication`, `#abstraction`

---

## Refactoring: Extract Interface

**ID:** `ref_extract_interface`
**Purpose:** If multiple classes have a common subset of their public interface, or if you want to define a contract that different classes (related or unrelated by inheritance) can implement, extract that common public interface into a new explicit interface.
**When to Use:**
* When several classes share a common set of operations (method signatures) but may have different implementations.
* To decouple clients from specific implementations by programming to an interface rather than a concrete class.
* When a class has distinct sets of operations used by different types of clients (can extract multiple interfaces to define different roles the class plays - Role Interface pattern).
* To address `smell_large_class` by defining clear contracts for parts of its functionality.
* When you want to allow for future implementations that are not yet known.
**Benefits:**
* Promotes loose coupling and reduces dependencies on concrete classes.
* Allows for greater flexibility and easier substitution of implementations (e.g., for testing, different strategies).
* Clearly defines contracts for behavior, improving system design and understandability.
* Enables polymorphism across unrelated class hierarchies.
**Related Smells:**
* `smell_large_class` (by defining roles it plays)
* `smell_alternative_classes_different_interfaces` (an interface can define the common contract)
* `smell_divergent_change` (if different interfaces serve different reasons for change, promoting SRP for clients)
* `smell_shotgun_surgery` (if clients depend on concrete classes that frequently change, an interface can stabilize the dependency)
**Tags:** `#dealing-with-generalization`, `#abstraction`, `#decoupling`, `#polymorphism`, `#interface-design`

---

## Refactoring: Collapse Hierarchy

**ID:** `ref_collapse_hierarchy`
**Purpose:** If a superclass and subclass are not very different, are not evolving separately, or the hierarchy adds unnecessary complexity, merge them into a single class.
**When to Use:**
* When an inheritance hierarchy is no longer providing significant value or has become too simple to justify its existence.
* When a subclass (`smell_lazy_class`) adds very little (or no) new behavior or data to its superclass.
* To simplify the class structure when the distinction between superclass and subclass is artificial or unhelpful.
* When a planned hierarchy (`smell_speculative_generality`) never materialized into meaningful distinctions.
**Benefits:**
* Reduces complexity by decreasing the number of classes in the system.
* Removes unnecessary indirection and abstraction layers.
* Makes the code easier to understand if the hierarchy was trivial.
**Related Smells:**
* `smell_lazy_class` (for the subclass or even a superclass that became trivial)
* `smell_speculative_generality` (if the hierarchy was over-engineered)
* `smell_refused_bequest` (if the subclass is so different that merging it, after possibly moving unique features, simplifies things more than keeping a bad hierarchy)
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#simplification`

---

## Refactoring: Form Template Method

**ID:** `ref_form_template_method`
**Purpose:** If subclasses implement algorithms that are similar in overall structure but differ in specific, individual steps, create a "template method" in the superclass that outlines the algorithm's skeleton. The differing steps are implemented by abstract or overridable "primitive" methods in the superclass, which subclasses then provide concrete implementations for.
**When to Use:**
* When you have `smell_duplicate_code` in methods of subclasses that follow the same general sequence of operations but vary in the details of those operations.
* To define a fixed algorithm structure while allowing subclasses to customize parts of it without changing the overall flow.
* When you want to enforce a particular sequence of operations.
**Benefits:**
* Reduces code duplication by centralizing the common algorithm structure in the superclass.
* Clearly defines the overall algorithm and the specific points of variation (primitive operations).
* Follows the Open/Closed Principle for the variant parts: new variations can be added by creating new subclasses that implement the primitive operations.
* Promotes reuse of the common algorithm structure.
**Related Smells:**
* `smell_duplicate_code` (specifically when subclasses have similar method structures)
* `smell_pull_up_method` can be a precursor if common parts are first pulled up, then structured into a template method.
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#design-patterns` (Template Method pattern), `#behavioral-patterns`, `#duplication`

---

## Refactoring: Replace Inheritance with Delegation

**ID:** `ref_replace_inheritance_with_delegation`
**Purpose:** If inheritance is being misused (e.g., subclass doesn't truly represent an "is-a" relationship with the superclass, or `smell_refused_bequest` is present where the subclass ignores or redefines much of the inherited behavior inappropriately), change the "subclass" to hold an instance of the "superclass" (now a delegate) and delegate relevant operations to it.
**When to Use:**
* When a subclass only uses a small portion of the superclass's interface or redefines most of it in ways that break the Liskov Substitution Principle (`smell_refused_bequest`).
* When inheritance leads to a rigid design, unwanted inherited features, or bloated subclasses.
* To break a `smell_parallel_inheritance_hierarchies` by having one hierarchy delegate to objects of the other.
* When you want to change the behavior provided by the "superclass" at runtime by changing the delegate.
* When multiple inheritance is desired but not supported by the language (can delegate to multiple objects).
**Benefits:**
* Increases flexibility; delegation can be changed at runtime.
* Avoids problems of fragile base classes and unwanted inherited members.
* Makes relationships clearer if "is-a" doesn't truly apply ("has-a" or "uses-a" is often better represented by delegation).
* Can reduce coupling compared to tight inheritance.
* Promotes the "Composition over Inheritance" principle.
**Related Smells:**
* `smell_refused_bequest`
* `smell_parallel_inheritance_hierarchies`
* `smell_inappropriate_intimacy` (sometimes through inheritance if subclasses access protected members too much)
* `smell_large_class` (if inheritance is making a class large with irrelevant features)
**Tags:** `#dealing-with-generalization`, `#composition-over-inheritance`, `#delegation`, `#flexibility`, `#decoupling`

---

## Refactoring: Replace Delegation with Inheritance

**ID:** `ref_replace_delegation_with_inheritance`
**Purpose:** If a class contains many simple delegations to all (or most) methods of another class (the delegate), and it makes conceptual sense for the containing class to be a subtype of the delegate, consider making the containing class a subclass of the delegate. This is the reverse of Replace Inheritance with Delegation.
**When to Use:**
* When a class is essentially a wrapper around another class and acts as a true subtype ("is-a" relationship is strong and clear).
* To simplify code if the delegation is extensive (forwarding many methods) and adds little or no new behavior beyond what the delegate provides.
* When the entire interface of the delegate needs to be exposed by the wrapper.
**Benefits:**
* Can reduce boilerplate delegation code, making the class smaller.
* Makes the subclass ("is-a") relationship explicit in the type system.
* Allows the new subclass to override methods from the new superclass naturally.
**Caution:** Use with care; inheritance introduces stronger coupling than delegation. Ensure Liskov Substitution Principle holds. This refactoring is less common than its inverse.
**Related Smells:**
* `smell_middle_man` (if the class is just a shell of delegations)
* `smell_lazy_class` (if the class does nothing but delegate)
**Tags:** `#dealing-with-generalization`, `#inheritance`, `#simplification` (in terms of less code, but potentially tighter coupling)

---

## Refactoring: Change Bidirectional Association to Unidirectional

**ID:** `ref_change_bidirectional_association_to_unidirectional`
**Purpose:** If two classes have references to each other (a bidirectional association), but one class can logically function and fulfill its responsibilities without knowing about the other, remove the unnecessary link from that class, making the association unidirectional.
**When to Use:**
* To reduce coupling between two classes when one side of the association is not strictly needed.
* When maintaining the consistency of a bidirectional link (ensuring both objects point to each other correctly) adds complexity or is error-prone.
* If one class can be reused in more contexts if it doesn't have a mandatory dependency on the other.
**Benefits:**
* Reduces coupling, making classes easier to understand, test, and maintain independently.
* Simplifies the design by removing a redundant or unnecessary association.
* Can improve reusability of the class that no longer holds the back-pointer.
**Related Smells:**
* `smell_inappropriate_intimacy` (if the bidirectional link leads to too much knowledge of each other)
* `smell_shotgun_surgery` or `smell_divergent_change` (if changes in one class due to the association frequently ripple to the other unnecessarily)
**Tags:** `#organizing-data`, `#coupling`, `#simplification`, `#dependency-management`
